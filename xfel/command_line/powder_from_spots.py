
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.powder_from_spots
import logging
from iotbx.phil import parse

from scitbx.array_family import flex

from dials.util import log
from dials.util import show_mail_on_error
from dials.util.options import OptionParser
from dials.util.version import dials_version

from dxtbx.model.experiment_list import DetectorComparison

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as tick

import pickle
import copy

logger = logging.getLogger("dials.command_line.powder_from_spots")

help_message = """
Script to synthesize a powder pattern from DIALS spotfinding output
Example usage:
cctbx.xfel.powder_from_spots all.expt all.refl

This computes d-spacings of peak maxima in a reflections file as generated by
dials.find_spots. The results are binned and plotted as a histogram. Plotting
only maxima (and thus discarding the rest of the peak profile) has a large
sharpening effect; the resulting patterns are better than those obtained by 
synchrotron powder diffraction.

The input is a single combined .refl file and the corresponding .expt file.
For small-molecule data, 10k to 20k shots are a minimum for good results.
Consider filtering the input by number of spots using the min_... and
max_reflections_per_experiment options of dials.combine_experiments. Min=3
and max=15 are a good starting point for small-molecule samples. 

An excellent reference geometry (rmsd <<1 px) is important. A current detector
metrology refined from a protein sample is probably the best approach. Try a
plot with split_panels=True to confirm that the patterns on each panel agree.
In a data set from the MPCCD detector at SACLA we found that the Tau2 and Tau3
tilts had to be refined for each panel.
"""

phil_scope = parse(
    """
  file_path = None
    .type = str
    .multiple = True
    .help = Files to read
  n_bins = 3000
    .type = int
    .help = Number of bins in the radial average
  d_max = 20
    .type = float
  d_min = 1.4
    .type = float
  verbose = True
    .type = bool
    .help = Extra logging information
  panel = None
    .type = int
    .help = Only use data from the specified panel
  reference_geometry = None
    .type = path
    .help = Apply this geometry before creating average. Not implemented.
  unit_cell = None
    .type = unit_cell
    .help = Show positions of miller indices from this unit_cell and space \
            group. Not implemented.
  space_group = None
    .type = space_group
    .help = Show positions of miller indices from this unit_cell and space \
            group. Not implemented.
  peak_position = *xyzobs shoebox
    .type = choice
    .help = By default, use the d-spacing of the peak maximum. Shoebox: Use the \
            coordinates of every pixel in the reflection shoebox. This entails \
            intensity-weighted peaks.
  peak_weighting = *unit intensity
    .type = choice
    .help = The histogram may be intensity-weighted, but the results are \
            typically not very good.
  downweight_weak = 0
    .type = float
    .help = Subtract a constant from every intensity. May help filter out \
            impurity peaks.
  split_panels = False
    .type = bool
    .help = Plot a pattern for each detector panel.
  xyz_offset = 0. 0. 0.
    .type = floats
    .help = origin offset in millimeters
output {
  log = dials.powder_from_spots.log
    .type = str
  xy_file = None
    .type = str
}
"""
)


class Script(object):
  def __init__(self):
    usage = "$ cctbx.xfel.powder_from_spots EXPERIMENTS REFLECTIONS [options]"
    self.parser = OptionParser(
        usage=usage,
        phil=phil_scope,
        epilog=help_message,
        check_format=False,
        read_reflections=True,
        read_experiments=True,
        )

  def run(self):

    def _process_pixel(params, panelsums, i_panel, s0, panel, xy, value):
      value -= params.downweight_weak
      d_max_inv = 1/params.d_max
      d_min_inv = 1/params.d_min
      res_inv = 1 / panel.get_resolution_at_pixel(s0, xy)
      n_bins = params.n_bins
      i_bin = int(
          n_bins * (res_inv - d_inv_low) / (d_inv_high - d_inv_low)
          )
      if i_bin < 0 or i_bin >= n_bins: return
      panelsums[i_panel][i_bin] += value


    params, options = self.parser.parse_args(show_diff_phil=False)

    log.config(verbosity=options.verbose, logfile=params.output.log)
    logger.info(dials_version())

    assert len(params.input.reflections)==1, "Please supply 1 reflections file"
    assert len(params.input.experiments)==1, "Please supply 1 experiments file"

    # setup limits and bins
    n_bins = params.n_bins
    d_max, d_min = params.d_max, params.d_min
    d_inv_low, d_inv_high = 1/d_max, 1/d_min
    unit_wt = (params.peak_weighting == "unit")


    # TODO: get n_panels from expt
    panelsums = [flex.double(params.n_bins) for _ in range(8)]
    d_table = []

    refls = params.input.reflections[0].data
    expts = params.input.experiments[0].data

    if not np.allclose(params.xyz_offset, [0,0,0]):

      corrected_detector = copy.deepcopy(expts[0].detector)
      hierarchy = corrected_detector.hierarchy()
      fast = hierarchy.get_local_fast_axis()
      slow = hierarchy.get_local_slow_axis()
      origin = hierarchy.get_local_origin()
      corrected_origin = (
              origin[0] + params.xyz_offset[0],
              origin[1] + params.xyz_offset[1],
              origin[2] + params.xyz_offset[2]
              )
      hierarchy.set_local_frame(fast, slow, corrected_origin)

      compare_detector = DetectorComparison()
      ref_detector = copy.deepcopy(expts.detectors()[0])
      for expt in expts:
        assert compare_detector(ref_detector, expt.detector)
        expt.detector = corrected_detector

    for i, expt in enumerate(expts):
      if i % 1000 == 0: print("experiment ", i)
      s0 = expt.beam.get_s0()
      sel = refls['id'] == i
      refls_sel = refls.select(sel)
      xyzobses = refls_sel['xyzobs.px.value']
      intensities = refls_sel['intensity.sum.value']
      panels = refls_sel['panel']
      shoeboxes = refls_sel['shoebox']

      for i_refl in range(len(refls_sel)):
        i_panel = panels[i_refl]
        panel = expt.detector[i_panel]
        
        peak_height = intensities[i_refl]
        if params.peak_position=="xyzobs":
          xy = xyzobses[i_refl][0:2]
          if params.peak_weighting == "intensity":
            value = intensities[i_refl]
          else:
            value = 1
          _process_pixel(params, panelsums, i_panel, s0, panel, xy, value)
        if params.peak_position=="shoebox":
          sb = shoeboxes[i_refl]
          sbpixels = zip(sb.coords(), sb.values())
          for (x,y,_), value in sbpixels:
            _process_pixel(params, panelsums, i_panel, s0, panel, (x,y), value)

    xvalues = np.linspace(d_inv_low, d_inv_high, n_bins)
    fig, ax = plt.subplots()
    if params.split_panels:
      # TODO: better way to stack the split patterns
      offset = 0.5*max(np.array(panelsums[0]))
      for i_sums, sums in enumerate(panelsums):
        yvalues = np.array(sums)
        plt.plot(xvalues, yvalues+0.5*i_sums*offset)
    else:
      yvalues = sum(panelsums)
      plt.plot(xvalues, yvalues)
    ax.get_xaxis().set_major_formatter(tick.FuncFormatter(
      lambda x, _: "{:.3f}".format(1/x)))

    if params.output.xy_file:
      with open(params.output.xy_file, 'w') as f:
        for x,y in zip(xvalues, yvalues):
          f.write("{:.6f}\t{}\n".format(1/x, y))
    plt.show()

if __name__ == "__main__":
  with show_mail_on_error():
    script = Script()
    script.run()
